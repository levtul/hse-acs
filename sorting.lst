     1                                  
     2                                  section .text
     3                                  
     4                                  extern memcpy
     5                                  
     6                                  strlen:
     7                                      ; Адрес сообщения уже загружен в rdi
     8 00000000 48C7C1FFFFFFFF              mov rcx, -1     ; ecx должен быть < 0
     9 00000007 30C0                        xor al, al      ; конечный симврл = 0
    10 00000009 FC                          cld             ; направление обхода от начала к концу
    11 0000000A F2AE                        repne   scasb   ; while(msg[rdi]) != al) {rdi++, rcx--}
    12 0000000C 48F7D9                      neg rcx
    13 0000000F 4883E902                    sub rcx, 2      ; ecx = length(msg)
    14 00000013 4889C8                      mov rax, rcx
    15 00000016 C3                          ret
    16                                  
    17                                  ;double CompareValue(void *l) {
    18                                  ;    int len = strlen((char*)l);
    19                                  ;    return (double) *(int*)(l + nameSize) / len;
    20                                  ;}
    21                                  global CompareValue
    22                                  CompareValue:
    23 00000017 55                          push    rbp
    24 00000018 4889E5                      mov     rbp, rsp
    25 0000001B 4883EC0C                    sub     rsp, 12; двиагаем stack pointer на 12 вниз
    26 0000001F 48897DF8                    mov     [rbp - 8], rdi; сохраняем l
    27 00000023 E8D8FFFFFF                  call    strlen
    28 00000028 8945F4                      mov     [rbp - 12], eax; сохраняем длину  
    29 0000002B 488B45F8                    mov     rax, [rbp - 8]; записываем l
    30 0000002F F20F2A401E                  cvtsi2sd        xmm0, [rax + 30]; берем creation_year и переводим в double
    31 00000034 F20F2A4DF4                  cvtsi2sd        xmm1, [rbp - 12]; берем длину и переводим в double
    32 00000039 F20F5EC1                    divsd   xmm0, xmm1; делим
    33 0000003D 4883C40C                    add     rsp, 12; возвращаем обратно stack pointer
    34 00000041 5D                          pop     rbp
    35 00000042 C3                          ret
    36                                  
    37                                  ; void ShellSort(void *c, int len)
    38                                  ;     for (int d = len / 2; d > 0; d /= 2)
    39                                  ;         for (int i = d; i < len; i++)
    40                                  ;             for (int j = i; j >= d && CompareValue(c + j * languageSize + intSize) < CompareValue(c + (j - d) * languageSize + intSize); j -= d) {
    41                                  ;                 void *tmp[languageSize];
    42                                  ;                 memcpy(tmp, c + j * languageSize, languageSize);
    43                                  ;                 memcpy(c + j * languageSize, c + (j - d) * (languageSize), languageSize);
    44                                  ;                 memcpy(c + (j - d) * (languageSize), tmp, languageSize);
    45                                  ;             }
    46                                  global ShellSort
    47                                  ShellSort:
    48 00000043 55                              push    rbp
    49 00000044 4889E5                          mov     rbp, rsp
    50 00000047 4883EC40                        sub     rsp, 64; двигаем стек для хранения переменных
    51 0000004B 48897DF8                        mov     [rbp - 8], rdi; сохраняем l
    52 0000004F 8975F4                          mov     [rbp - 12], esi; сохраняем len
    53 00000052 8B45F4                          mov     eax, [rbp - 12]
    54 00000055 B902000000                      mov     ecx, 2
    55 0000005A 99                              cdq     ; расширяем eax для деления
    56 0000005B F7F9                            idiv    ecx
    57 0000005D 8945F0                          mov     [rbp - 16], eax; сохраняем d
    58                                  .outer_loop:                                ; =>This Loop Header: Depth=1
    59 00000060 837DF000                        cmp     dword [rbp - 16], 0; если d <= 0
    60 00000064 0F8E19010000                    jle     .leave_outer_cycle; заканчиваем
    61 0000006A 8B45F0                          mov     eax, [rbp - 16]
    62 0000006D 8945EC                          mov     [rbp - 20], eax; сохраняем i
    63                                  .inner_loop:
    64 00000070 8B45EC                          mov     eax, [rbp - 20]
    65 00000073 3B45F4                          cmp     eax, [rbp - 12]; если i >= d
    66 00000076 0F8DF4000000                    jge     .step_outer_loop
    67 0000007C 8B45EC                          mov     eax, [rbp - 20]
    68 0000007F 8945E8                          mov     [rbp - 24], eax; j = i
    69                                  .inner_inner_loop:
    70 00000082 8B45E8                          mov     eax, [rbp - 24]; j
    71 00000085 3B45F0                          cmp     eax, [rbp - 16]; если j < d
    72 00000088 0F8CD5000000                    jl      .step_inner_loop
    73 0000008E 488B7DF8                        mov     rdi, [rbp - 8]; кладем в первый аргумент l
    74 00000092 6B45E832                        imul    eax, [rbp - 24], 50; j * language_size
    75 00000096 4898                            cdqe
    76 00000098 4801C7                          add     rdi, rax; c + j * language_size
    77 0000009B 4883C704                        add     rdi, 4;  c + j * language_size + intSize
    78 0000009F E873FFFFFF                      call    CompareValue
    79 000000A4 F20F1145E0                      movsd   [rbp - 32], xmm0; сохраним CompareValue(c + j * language_size + intSize)
    80 000000A9 488B7DF8                        mov     rdi, [rbp - 8]; делаем все то же самое для c + (j - d) * language_size + intSize
    81 000000AD 8B45E8                          mov     eax, [rbp - 24]
    82 000000B0 2B45F0                          sub     eax, [rbp - 16]
    83 000000B3 6BC032                          imul    eax, eax, 50
    84 000000B6 4898                            cdqe
    85 000000B8 4801C7                          add     rdi, rax
    86 000000BB 4883C704                        add     rdi, 4
    87 000000BF E853FFFFFF                      call    CompareValue
    88 000000C4 F20F1145D8                      movsd   [rbp - 40], xmm0; сохраним CompareValue(c + (j - d) * language_size + intSize)
    89 000000C9 F20F1045E0                      movsd   xmm0, [rbp - 32]
    90 000000CE 660F2E45D8                      ucomisd xmm0, [rbp - 40]; если cv1 < cv2
    91 000000D3 7205                            jb      .swap; меняем местами элементы
    92 000000D5 E989000000                      jmp     .step_inner_loop; иначе начинаем заново
    93                                  .swap:
    94 000000DA 488965D0                        mov     [rbp - 48], rsp; запомним место под tmp
    95 000000DE 4889E7                          mov     rdi, rsp; первый аргумент - tmp
    96 000000E1 4881C770FEFFFF                  add     rdi, -400
    97 000000E8 48897DC8                        mov     [rbp - 56], rdi
    98 000000EC 4889FC                          mov     rsp, rdi
    99 000000EF 488B75F8                        mov     rsi, [rbp - 8]; c
   100 000000F3 6B45E832                        imul    eax, [rbp - 24], 50; j * languageSize
   101 000000F7 4898                            cdqe
   102 000000F9 4801C6                          add     rsi, rax; второй аргумент - c + j * languageSize
   103 000000FC BA32000000                      mov     edx, 50; третий аргумент - languageSize
   104 00000101 E8(00000000)                    call    memcpy; memcpy(tmp, c + j * languageSize, languageSize)
   105 00000106 488B7DF8                        mov     rdi, [rbp - 8]; c
   106 0000010A 6B45E832                        imul    eax, [rbp - 24], 50; j * languageSize
   107 0000010E 4898                            cdqe
   108 00000110 4801C7                          add     rdi, rax ; первый аргумет - c + j * languageSize
   109 00000113 488B75F8                        mov     rsi, [rbp - 8]; аналогичное вычисление c + (j - d) * (languageSize)
   110 00000117 8B45E8                          mov     eax, [rbp - 24]
   111 0000011A 2B45F0                          sub     eax, [rbp - 16]
   112 0000011D 6BC032                          imul    eax, eax, 50
   113 00000120 4898                            cdqe
   114 00000122 4801C6                          add     rsi, rax; второй аргумент - c + (j - d) * (languageSize)
   115 00000125 BA32000000                      mov     edx, 50; третий аргумент - languageSize
   116 0000012A E8(00000000)                    call    memcpy; memcpy(c + j * languageSize, c + (j - d) * (languageSize), languageSize)
   117 0000012F 488B75C8                        mov     rsi, [rbp - 56]; полностью аналогичный вызов memcpy(c + (j - d) * (languageSize), tmp, languageSize);
   118 00000133 488B7DF8                        mov     rdi, [rbp - 8]
   119 00000137 8B45E8                          mov     eax, [rbp - 24]
   120 0000013A 2B45F0                          sub     eax, [rbp - 16]
   121 0000013D 6BC032                          imul    eax, eax, 50
   122 00000140 4898                            cdqe
   123 00000142 4801C7                          add     rdi, rax
   124 00000145 BA32000000                      mov     edx, 50
   125 0000014A E8(00000000)                    call    memcpy; memcpy(c + (j - d) * (languageSize), tmp, languageSize);
   126                                  .inner_inner_loop_step:        
   127 0000014F 8B4DF0                          mov     ecx, [rbp - 16]; d
   128 00000152 8B45E8                          mov     eax, [rbp - 24]; j
   129 00000155 29C8                            sub     eax, ecx; j - d
   130 00000157 8945E8                          mov     [rbp - 24], eax; j = j - d;
   131 0000015A 488B65D0                        mov     rsp, [rbp - 48]; возвращаем стек обратно
   132 0000015E E91FFFFFFF                      jmp     .inner_inner_loop
   133                                  .step_inner_loop:
   134 00000163 8B45EC                          mov     eax, [rbp - 20]; i
   135 00000166 FFC0                            inc     eax; i + 1
   136 00000168 8945EC                          mov     [rbp - 20], eax; i = i + 1
   137 0000016B E900FFFFFF                      jmp     .inner_loop
   138                                  .step_outer_loop:
   139 00000170 8B45F0                          mov     eax, [rbp - 16]; d
   140 00000173 B902000000                      mov     ecx, 2
   141 00000178 99                              cdq
   142 00000179 F7F9                            idiv    ecx ; d / 2
   143 0000017B 8945F0                          mov     [rbp - 16], eax; d /= 2;
   144 0000017E E9DDFEFFFF                      jmp     .outer_loop
   145                                  .leave_outer_cycle:
   146 00000183 4889EC                          mov     rsp, rbp
   147 00000186 5D                              pop     rbp
   148 00000187 C3                              ret
